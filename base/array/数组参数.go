package main

import "fmt"

/**
在Go语言中函数的参数有两种传递方式，按值传递和按引用传递。
Go默认使用按值传递来传递参数，也就是传递参数的副本，在函数中对副本的值进行更改操作时，不会影响到原来的变量。
按引用传递其实也可以称作"按址传递"，只不过该副本是一个地址的拷贝，通过它可以修改这个值所指向的地址上的值。

Go语言中，在函数调用时，引用类型（slice、map、interface、channel）都默认使用引用传递。


Go语言在将数组名作为函数参数的时候，参数传递即是对数组的复制。在形参中对数组元素的修改都不会影响到数组元素原来的值。

而在使用slice作为函数参数时，进行参数传递将是一个地址拷贝，即将底层数组的内存地址复制给参数slice。这时，对slice元素的操作就是对底层数组元素的操作。

采用指针方式进行传递就是传递的引用，对这个引用指向的地址的内容进行修改也会影响原数组的值。


数组传递时的一些缺点:

一般情况下，传递指针的消耗比传递副本的少，尤其是当数组特别大时。具体原因是：

值传递需要完整的复制初始数组并将这份拷贝放到栈中，这将耗费大量运行时间，因而值传递方式的效率比较低。
初始数组的拷贝需要占用额外的内存空间（栈中的内存）
编译程序需要专门产生一部分用来复制初始数组的代码，这将使程序变大。

*/

// 值传递，对原数组进行拷贝
func testArr01(arr [5]int) { // 数组指定大小
	arr[0]++
	fmt.Println(arr) // [1 2 3 17 50]
}

// 引用传递，指针形式传的是数组的地址，会改变原来的数组
func testArr02(arr *[5]int) { // 数组指定大小
	arr[0]++
	fmt.Println(*arr) // [1 2 3 17 50]
}

func testArr03(arr []int) { // 形参未指定大小
	arr[0]++
	fmt.Println(arr) //[1 2 3 17 50]
}

func main() {
	var arr = [5]int{0, 2, 3, 17, 50}

	// 值传递
	testArr01(arr)
	fmt.Println(arr) // [0 2 3 17 50]

	fmt.Println()

	// 引用传递 会影响原始数组
	var arr2 = [5]int{0, 2, 3, 17, 50}
	testArr02(&arr2)
	fmt.Println(arr2)

	fmt.Println()

	// 切片传递 会影响原始数组
	var arr3 = [5]int{0, 2, 3, 17, 50}
	testArr03(arr3[:]) // 切片方式传递（常用）
	fmt.Println(arr3)  // [1 2 3 17 50]

}
